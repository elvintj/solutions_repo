{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Introduction Projectile motion describes the movement of an object under the influence of gravity after an initial launch. The horizontal distance traveled by a projectile, known as its range, depends on several factors, including the initial velocity and angle of projection. This investigation explores the relationship between the launch angle and the range of a projectile. Theory Projectile motion can be analyzed using kinematic equations, considering separate horizontal and vertical components: Horizontal motion: $$ x = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: $$ y = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ where: - \\( x \\) and \\( y \\) are the horizontal and vertical displacements, - \\( v_0 \\) is the initial velocity, - \\( \\theta \\) is the launch angle, - \\( g \\) is the gravitational acceleration (9.81 m/s\u00b2), - \\( t \\) is the time of flight. Time of Flight The total time a projectile remains in motion before hitting the ground can be found by setting \\( y = 0 \\) : $$ T = \\frac{2 v_0 \\sin(\\theta)}{g} $$ Range of the Projectile The range \\( R \\) is the total horizontal distance covered: $$ R = v_0 \\cos(\\theta) \\cdot T $$ Substituting \\( T \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ From this equation, the maximum range is achieved when \\( \\sin(2\\theta) \\) is maximized, which occurs at \\( \\theta = 45^\\circ \\) . Implementation A Python script can be used to simulate projectile motion and visualize how the range varies with the launch angle. import numpy as np import matplotlib.pyplot as plt def compute_range(v_0, g, angles): \"\"\"Computes the range of a projectile for different launch angles.\"\"\" ranges = (v_0**2 * np.sin(2 * np.radians(angles))) / g return ranges # Parameters v_0 = 25 # Initial velocity (m/s) g = 9.81 # Acceleration due to gravity (m/s\u00b2) angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees # Compute ranges ranges = compute_range(v_0, g, angles) # Plot results plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v_0 = {v_0} m/s') plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs Launch Angle\") plt.legend() plt.grid() plt.show() Figure 1: Sample Trajectories of Projectile Motion","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#introduction","text":"Projectile motion describes the movement of an object under the influence of gravity after an initial launch. The horizontal distance traveled by a projectile, known as its range, depends on several factors, including the initial velocity and angle of projection. This investigation explores the relationship between the launch angle and the range of a projectile.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theory","text":"Projectile motion can be analyzed using kinematic equations, considering separate horizontal and vertical components: Horizontal motion: $$ x = v_0 \\cos(\\theta) \\cdot t $$ Vertical motion: $$ y = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ where: - \\( x \\) and \\( y \\) are the horizontal and vertical displacements, - \\( v_0 \\) is the initial velocity, - \\( \\theta \\) is the launch angle, - \\( g \\) is the gravitational acceleration (9.81 m/s\u00b2), - \\( t \\) is the time of flight.","title":"Theory"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The total time a projectile remains in motion before hitting the ground can be found by setting \\( y = 0 \\) : $$ T = \\frac{2 v_0 \\sin(\\theta)}{g} $$","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-of-the-projectile","text":"The range \\( R \\) is the total horizontal distance covered: $$ R = v_0 \\cos(\\theta) \\cdot T $$ Substituting \\( T \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ From this equation, the maximum range is achieved when \\( \\sin(2\\theta) \\) is maximized, which occurs at \\( \\theta = 45^\\circ \\) .","title":"Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation","text":"A Python script can be used to simulate projectile motion and visualize how the range varies with the launch angle. import numpy as np import matplotlib.pyplot as plt def compute_range(v_0, g, angles): \"\"\"Computes the range of a projectile for different launch angles.\"\"\" ranges = (v_0**2 * np.sin(2 * np.radians(angles))) / g return ranges # Parameters v_0 = 25 # Initial velocity (m/s) g = 9.81 # Acceleration due to gravity (m/s\u00b2) angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees # Compute ranges ranges = compute_range(v_0, g, angles) # Plot results plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v_0 = {v_0} m/s') plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs Launch Angle\") plt.legend() plt.grid() plt.show() Figure 1: Sample Trajectories of Projectile Motion","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Introduction The forced damped pendulum is a fascinating physical system where the interplay of damping, restoring forces, and external periodic driving results in a wide range of complex behaviors. These include resonance, quasiperiodicity, and even chaos. Understanding these behaviors is crucial for applications in engineering, mechanical resonance systems, and nonlinear dynamics. Theory The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\( \\theta \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega_0 \\) is the natural frequency of the pendulum, - \\( A \\) is the amplitude of the external forcing, - \\( \\omega \\) is the frequency of the external forcing, - \\( t \\) represents time. Small-Angle Approximation For small oscillations (i.e., \\( \\theta \\ll 1 \\) ), we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to the linearized equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a transient part and a steady-state solution: \\[ \\theta(t) = \\theta_0 e^{-\\gamma t} + C \\cos(\\omega t - \\phi) \\] where \\( \\phi \\) is the phase shift. Resonance Conditions Resonance occurs when the external forcing frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 \\) , amplifying oscillations significantly. The amplitude of the steady-state oscillation is given by: \\[ \\theta_{max} = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}} \\] Implementation A computational approach helps visualize the impact of damping, external forcing, and initial conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define parameters gamma = 0.1 # Damping coefficient omega_0 = 1.0 # Natural frequency A = 0.5 # Forcing amplitude omega = 1.2 # Driving frequency def pendulum_eq(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions y0 = [0.1, 0] # Small initial angle, zero initial velocity # Time range tspan = (0, 50) t_eval = np.linspace(*tspan, 1000) # Solving the system sol = solve_ivp(pendulum_eq, tspan, y0, t_eval=t_eval) # Plotting results plt.figure(figsize=(8,5)) plt.plot(sol.t, sol.y[0], label='Angle \u03b8(t)') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() Simulated Angular Displacement Over Time","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#introduction","text":"The forced damped pendulum is a fascinating physical system where the interplay of damping, restoring forces, and external periodic driving results in a wide range of complex behaviors. These include resonance, quasiperiodicity, and even chaos. Understanding these behaviors is crucial for applications in engineering, mechanical resonance systems, and nonlinear dynamics.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theory","text":"The motion of a forced damped pendulum is governed by the nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\( \\theta \\) is the angular displacement, - \\( \\gamma \\) is the damping coefficient, - \\( \\omega_0 \\) is the natural frequency of the pendulum, - \\( A \\) is the amplitude of the external forcing, - \\( \\omega \\) is the frequency of the external forcing, - \\( t \\) represents time.","title":"Theory"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations (i.e., \\( \\theta \\ll 1 \\) ), we approximate \\( \\sin(\\theta) \\approx \\theta \\) , leading to the linearized equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a transient part and a steady-state solution: \\[ \\theta(t) = \\theta_0 e^{-\\gamma t} + C \\cos(\\omega t - \\phi) \\] where \\( \\phi \\) is the phase shift.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the external forcing frequency \\( \\omega \\) is close to the natural frequency \\( \\omega_0 \\) , amplifying oscillations significantly. The amplitude of the steady-state oscillation is given by: \\[ \\theta_{max} = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}} \\]","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#implementation","text":"A computational approach helps visualize the impact of damping, external forcing, and initial conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define parameters gamma = 0.1 # Damping coefficient omega_0 = 1.0 # Natural frequency A = 0.5 # Forcing amplitude omega = 1.2 # Driving frequency def pendulum_eq(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions y0 = [0.1, 0] # Small initial angle, zero initial velocity # Time range tspan = (0, 50) t_eval = np.linspace(*tspan, 1000) # Solving the system sol = solve_ivp(pendulum_eq, tspan, y0, t_eval=t_eval) # Plotting results plt.figure(figsize=(8,5)) plt.plot(sol.t, sol.y[0], label='Angle \u03b8(t)') plt.xlabel('Time (s)') plt.ylabel('Angular Displacement (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() Simulated Angular Displacement Over Time","title":"Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Introduction Kepler's Third Law states that the square of the orbital period (T) of a planet is proportional to the cube of its orbital radius (r). This relationship is fundamental in celestial mechanics and allows astronomers to determine planetary motions, calculate masses of celestial bodies, and estimate distances in space. The law is derived from Newton's Law of Gravitation and is widely applicable to satellites, planetary systems, and even galaxies. Theory For a body in a circular orbit around a massive central object, the gravitational force provides the necessary centripetal force: \\[ F_g = F_c \\] Using Newton\u2019s Law of Gravitation: [ \\frac{G M m}{r^2} = \\frac{m v^2}{r} ] where: - \\( G \\) is the gravitational constant \\( (6.674 \\times 10^{-11} \\text{ m}^3 \\text{kg}^{-1} \\text{s}^{-2}) \\) , - \\( M \\) is the mass of the central object, - \\( m \\) is the mass of the orbiting body, - \\( r \\) is the orbital radius, - \\( v \\) is the orbital velocity. Since the velocity in a circular orbit is given by: [ v = \\frac{2 \\pi r}{T} ] Substituting \\( v \\) and simplifying: [ \\frac{G M}{r} = \\left( \\frac{2 \\pi r}{T} \\right)^2 ] Rearranging: [ T^2 = \\frac{4 \\pi^2}{G M} r^3 ] which shows that \\( T^2 \\propto r^3 \\) , confirming Kepler\u2019s Third Law. Implementation A Python script can be used to verify this relationship by simulating circular orbits and plotting \\( T^2 \\) vs. \\( r^3 \\) . import numpy as np import matplotlib.pyplot as plt def orbital_period(radius, M, G=6.674e-11): return 2 * np.pi * np.sqrt(radius**3 / (G * M)) # Parameters M = 5.972e24 # Mass of Earth (kg) radii = np.linspace(1e7, 5e7, 100) # Orbital radii in meters T_values = orbital_period(radii, M) # Squaring period and cubing radius T_squared = T_values**2 r_cubed = radii**3 # Plot results plt.figure(figsize=(8, 5)) plt.plot(r_cubed, T_squared, label='T^2 vs r^3') plt.xlabel(\"Orbital Radius Cubed (m\u00b3)\") plt.ylabel(\"Orbital Period Squared (s\u00b2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() Graphical verification of Kepler's Third Law","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"Kepler's Third Law states that the square of the orbital period (T) of a planet is proportional to the cube of its orbital radius (r). This relationship is fundamental in celestial mechanics and allows astronomers to determine planetary motions, calculate masses of celestial bodies, and estimate distances in space. The law is derived from Newton's Law of Gravitation and is widely applicable to satellites, planetary systems, and even galaxies.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theory","text":"For a body in a circular orbit around a massive central object, the gravitational force provides the necessary centripetal force: \\[ F_g = F_c \\] Using Newton\u2019s Law of Gravitation: [ \\frac{G M m}{r^2} = \\frac{m v^2}{r} ] where: - \\( G \\) is the gravitational constant \\( (6.674 \\times 10^{-11} \\text{ m}^3 \\text{kg}^{-1} \\text{s}^{-2}) \\) , - \\( M \\) is the mass of the central object, - \\( m \\) is the mass of the orbiting body, - \\( r \\) is the orbital radius, - \\( v \\) is the orbital velocity. Since the velocity in a circular orbit is given by: [ v = \\frac{2 \\pi r}{T} ] Substituting \\( v \\) and simplifying: [ \\frac{G M}{r} = \\left( \\frac{2 \\pi r}{T} \\right)^2 ] Rearranging: [ T^2 = \\frac{4 \\pi^2}{G M} r^3 ] which shows that \\( T^2 \\propto r^3 \\) , confirming Kepler\u2019s Third Law.","title":"Theory"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implementation","text":"A Python script can be used to verify this relationship by simulating circular orbits and plotting \\( T^2 \\) vs. \\( r^3 \\) . import numpy as np import matplotlib.pyplot as plt def orbital_period(radius, M, G=6.674e-11): return 2 * np.pi * np.sqrt(radius**3 / (G * M)) # Parameters M = 5.972e24 # Mass of Earth (kg) radii = np.linspace(1e7, 5e7, 100) # Orbital radii in meters T_values = orbital_period(radii, M) # Squaring period and cubing radius T_squared = T_values**2 r_cubed = radii**3 # Plot results plt.figure(figsize=(8, 5)) plt.plot(r_cubed, T_squared, label='T^2 vs r^3') plt.xlabel(\"Orbital Radius Cubed (m\u00b3)\") plt.ylabel(\"Orbital Period Squared (s\u00b2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() Graphical verification of Kepler's Third Law","title":"Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Introduction The concept of escape velocity is essential for understanding the conditions necessary to leave a celestial body's gravitational influence. Beyond this, the first, second, and third cosmic velocities are crucial for space exploration, determining the thresholds for orbiting, escaping, and leaving a star system. These principles are vital for satellite launches, interplanetary missions, and potential interstellar travel. Theory First Cosmic Velocity : The first cosmic velocity is the minimum speed needed for an object to enter a stable orbit around a celestial body. This velocity depends on the mass of the body and the radius of the orbit. The formula is derived from the balance between gravitational force and centripetal force for a circular orbit: [ v_1 = \\sqrt{\\frac{GM}{R}} ] where: \\( G \\) is the gravitational constant, \\( M \\) is the mass of the celestial body, \\( R \\) is the radius of the orbit. Second Cosmic Velocity : The second cosmic velocity is the escape velocity, the speed required to escape the gravitational influence of a celestial body. It is derived by equating kinetic and potential energy: [ v_2 = \\sqrt{\\frac{2GM}{R}} ] where: \\( G \\) , \\( M \\) , and \\( R \\) have the same definitions as in the first cosmic velocity. Third Cosmic Velocity : The third cosmic velocity is the speed required for an object to escape the gravitational pull of a star system. It takes into account the gravitational influences of both the planet and the star: [ v_3 = \\sqrt{\\frac{2GM_{\\text{star}}}{R_{\\text{star}}} + \\frac{2GM_{\\text{planet}}}{R_{\\text{planet}}}} ] Mathematical Derivations The escape velocity is derived from energy conservation principles. The total mechanical energy at the surface of the celestial body (kinetic plus potential energy) must equal zero for the object to escape: [ \\frac{1}{2}mv^2 = \\frac{GMm}{R} ] This simplifies to the formula for escape velocity: [ v_2 = \\sqrt{\\frac{2GM}{R}} ] Calculations for Different Celestial Bodies Constants: Gravitational constant ( \\( G \\) ) = \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} \\) Earth : Mass ( \\( M_{\\text{Earth}} \\) ) = \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) Radius ( \\( R_{\\text{Earth}} \\) ) = \\( 6.371 \\times 10^6 \\, \\text{m} \\) Mars : Mass ( \\( M_{\\text{Mars}} \\) ) = \\( 0.64171 \\times 10^{24} \\, \\text{kg} \\) Radius ( \\( R_{\\text{Mars}} \\) ) = \\( 3.396 \\times 10^6 \\, \\text{m} \\) Jupiter : Mass ( \\( M_{\\text{Jupiter}} \\) ) = \\( 1.898 \\times 10^{27} \\, \\text{kg} \\) Radius ( \\( R_{\\text{Jupiter}} \\) ) = \\( 6.991 \\times 10^7 \\, \\text{m} \\) Python Implementation The following Python script calculates the first and second cosmic velocities for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 # Celestial body parameters (Mass in kg, Radius in m) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7} } # Calculate escape velocities (v_2) and orbital velocities (v_1) def calculate_velocities(mass, radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2 * G * mass / radius) return v1, v2 # Calculate velocities for each celestial body velocities = {} for body, params in celestial_bodies.items(): v1, v2 = calculate_velocities(params[\"mass\"], params[\"radius\"]) velocities[body] = {\"v1\": v1, \"v2\": v2} # Plotting the velocities labels = list(velocities.keys()) v1_values = [velocities[body][\"v1\"] for body in labels] v2_values = [velocities[body][\"v2\"] for body in labels] x = np.arange(len(labels)) fig, ax = plt.subplots(figsize=(8, 6)) bar_width = 0.35 ax.bar(x - bar_width/2, v1_values, bar_width, label='Orbital Velocity (v1)') ax.bar(x + bar_width/2, v2_values, bar_width, label='Escape Velocity (v2)') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape and Orbital Velocities of Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.show() Graphical representation of orbital and escape velocities for Earth, Mars, and Jupiter","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The concept of escape velocity is essential for understanding the conditions necessary to leave a celestial body's gravitational influence. Beyond this, the first, second, and third cosmic velocities are crucial for space exploration, determining the thresholds for orbiting, escaping, and leaving a star system. These principles are vital for satellite launches, interplanetary missions, and potential interstellar travel.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#theory","text":"First Cosmic Velocity : The first cosmic velocity is the minimum speed needed for an object to enter a stable orbit around a celestial body. This velocity depends on the mass of the body and the radius of the orbit. The formula is derived from the balance between gravitational force and centripetal force for a circular orbit: [ v_1 = \\sqrt{\\frac{GM}{R}} ] where: \\( G \\) is the gravitational constant, \\( M \\) is the mass of the celestial body, \\( R \\) is the radius of the orbit. Second Cosmic Velocity : The second cosmic velocity is the escape velocity, the speed required to escape the gravitational influence of a celestial body. It is derived by equating kinetic and potential energy: [ v_2 = \\sqrt{\\frac{2GM}{R}} ] where: \\( G \\) , \\( M \\) , and \\( R \\) have the same definitions as in the first cosmic velocity. Third Cosmic Velocity : The third cosmic velocity is the speed required for an object to escape the gravitational pull of a star system. It takes into account the gravitational influences of both the planet and the star: [ v_3 = \\sqrt{\\frac{2GM_{\\text{star}}}{R_{\\text{star}}} + \\frac{2GM_{\\text{planet}}}{R_{\\text{planet}}}} ]","title":"Theory"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"The escape velocity is derived from energy conservation principles. The total mechanical energy at the surface of the celestial body (kinetic plus potential energy) must equal zero for the object to escape: [ \\frac{1}{2}mv^2 = \\frac{GMm}{R} ] This simplifies to the formula for escape velocity: [ v_2 = \\sqrt{\\frac{2GM}{R}} ]","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-different-celestial-bodies","text":"","title":"Calculations for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"Gravitational constant ( \\( G \\) ) = \\( 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2} \\) Earth : Mass ( \\( M_{\\text{Earth}} \\) ) = \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) Radius ( \\( R_{\\text{Earth}} \\) ) = \\( 6.371 \\times 10^6 \\, \\text{m} \\) Mars : Mass ( \\( M_{\\text{Mars}} \\) ) = \\( 0.64171 \\times 10^{24} \\, \\text{kg} \\) Radius ( \\( R_{\\text{Mars}} \\) ) = \\( 3.396 \\times 10^6 \\, \\text{m} \\) Jupiter : Mass ( \\( M_{\\text{Jupiter}} \\) ) = \\( 1.898 \\times 10^{27} \\, \\text{kg} \\) Radius ( \\( R_{\\text{Jupiter}} \\) ) = \\( 6.991 \\times 10^7 \\, \\text{m} \\)","title":"Constants:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"The following Python script calculates the first and second cosmic velocities for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 # Celestial body parameters (Mass in kg, Radius in m) celestial_bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 0.64171e24, \"radius\": 3.396e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7} } # Calculate escape velocities (v_2) and orbital velocities (v_1) def calculate_velocities(mass, radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2 * G * mass / radius) return v1, v2 # Calculate velocities for each celestial body velocities = {} for body, params in celestial_bodies.items(): v1, v2 = calculate_velocities(params[\"mass\"], params[\"radius\"]) velocities[body] = {\"v1\": v1, \"v2\": v2} # Plotting the velocities labels = list(velocities.keys()) v1_values = [velocities[body][\"v1\"] for body in labels] v2_values = [velocities[body][\"v2\"] for body in labels] x = np.arange(len(labels)) fig, ax = plt.subplots(figsize=(8, 6)) bar_width = 0.35 ax.bar(x - bar_width/2, v1_values, bar_width, label='Orbital Velocity (v1)') ax.bar(x + bar_width/2, v2_values, bar_width, label='Escape Velocity (v2)') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Escape and Orbital Velocities of Different Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.tight_layout() plt.show() Graphical representation of orbital and escape velocities for Earth, Mars, and Jupiter","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth Motivation: When an object is released from a moving rocket near Earth, its trajectory is determined by its initial conditions (position, velocity, and altitude) and the gravitational forces acting on it. The study of these trajectories is crucial for various space mission scenarios such as deploying payloads, orbital insertion, reentry, and escape. Task: Analyze Possible Trajectories: Investigate the potential types of trajectories, including parabolic, hyperbolic, and elliptical orbits, based on the initial conditions of the payload (position, velocity, altitude). Understand how these trajectories relate to real-world space scenarios such as orbital insertion, reentry, or escape from Earth's gravity. Numerical Analysis: Use numerical methods to compute and simulate the path of the payload. Account for Earth's gravitational force on the payload, and determine how the velocity and position evolve over time. Simulation and Visualization: Develop a Python-based computational tool to simulate and visualize the motion of the payload under the influence of Earth's gravity. The tool should take initial velocity, position, and direction as input and simulate the payload's trajectory. Discuss Real-World Applications: Explore how these trajectories are relevant to space mission planning, satellite deployment, and planetary exploration. Provide insights on how to predict payload trajectories for various mission scenarios. Theory: Gravitational Principles: Newton\u2019s Law of Gravitation: The gravitational force acting on an object with mass m near Earth is given by: [ F = \\frac{G M_e m}{r^2} ] Where: - \\( F \\) is the gravitational force, - \\( G \\) is the gravitational constant ( \\( 6.674 \\times 10^{-11} \\, \\text{N} \\cdot \\text{m}^2 / \\text{kg}^2 \\) ), - \\( M_e \\) is Earth's mass ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), - \\( r \\) is the distance from the center of the Earth. Kepler's Laws: These laws describe the motion of planets (and payloads in orbit) under the influence of gravity: Elliptical Orbits: Planets (or objects in space) move in elliptical orbits with the Sun (or Earth, in our case) at one focus. Equal Areas in Equal Times: A line connecting a planet to the Sun sweeps out equal areas in equal times. Harmonic Law: The square of the orbital period of a planet is proportional to the cube of the semi-major axis of its orbit. Trajectory Types: Parabolic Trajectory: An object that has exactly the escape velocity will follow a parabolic trajectory. Elliptical Trajectory: An object in orbit will follow an elliptical path, which can be bound or unbound depending on the velocity and altitude. Hyperbolic Trajectory: If the object has more than the escape velocity, it will follow a hyperbolic trajectory and escape Earth\u2019s gravity. Escape Velocity: The escape velocity \\( v_e \\) is the minimum velocity needed for an object to escape Earth's gravitational influence, calculated as: \\[ v_e = \\sqrt{\\frac{2 G M_e}{r}} \\] Where: - \\( v_e \\) is the escape velocity, - \\( r \\) is the distance from the center of the Earth. Python Code: Numerical Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_e = 5.972e24 # Earth's mass (kg) R_e = 6371e3 # Earth's radius (m) # Initial conditions initial_position = np.array([7000e3, 0]) # Position (m) [x, y] initial_velocity = np.array([0, 10e3]) # Velocity (m/s) [vx, vy] # Time settings dt = 10 # Time step (seconds) T = 10000 # Total time for simulation (seconds) times = np.arange(0, T, dt) # Initialize arrays for position and velocity positions = [] velocities = [] position = initial_position velocity = initial_velocity # Function to compute the gravitational force def gravitational_force(position): r = np.linalg.norm(position) force_magnitude = G * M_e / r**2 force_direction = -position / r # Unit vector pointing towards Earth's center return force_magnitude * force_direction # Numerical integration (Euler's method) for t in times: positions.append(position) velocities.append(velocity) # Compute acceleration force = gravitational_force(position) acceleration = force / 1 # Assuming mass = 1 kg for simplicity # Update velocity and position using Euler's method velocity += acceleration * dt position += velocity * dt # Convert positions and velocities to arrays positions = np.array(positions) # Plot the trajectory plt.figure(figsize=(6, 6)) plt.plot(positions[:, 0], positions[:, 1], label='Trajectory') plt.scatter(0, 0, color='red', label='Earth') plt.title('Trajectory of a Freely Released Payload Near Earth') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend() plt.grid(True) plt.axis('equal') plt.show() Graphical representations of orbital trajectories, escape velocities, and payload trajectories near Earth.","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory is determined by its initial conditions (position, velocity, and altitude) and the gravitational forces acting on it. The study of these trajectories is crucial for various space mission scenarios such as deploying payloads, orbital insertion, reentry, and escape.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze Possible Trajectories: Investigate the potential types of trajectories, including parabolic, hyperbolic, and elliptical orbits, based on the initial conditions of the payload (position, velocity, altitude). Understand how these trajectories relate to real-world space scenarios such as orbital insertion, reentry, or escape from Earth's gravity. Numerical Analysis: Use numerical methods to compute and simulate the path of the payload. Account for Earth's gravitational force on the payload, and determine how the velocity and position evolve over time. Simulation and Visualization: Develop a Python-based computational tool to simulate and visualize the motion of the payload under the influence of Earth's gravity. The tool should take initial velocity, position, and direction as input and simulate the payload's trajectory. Discuss Real-World Applications: Explore how these trajectories are relevant to space mission planning, satellite deployment, and planetary exploration. Provide insights on how to predict payload trajectories for various mission scenarios.","title":"Task:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theory","text":"","title":"Theory:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-principles","text":"Newton\u2019s Law of Gravitation: The gravitational force acting on an object with mass m near Earth is given by: [ F = \\frac{G M_e m}{r^2} ] Where: - \\( F \\) is the gravitational force, - \\( G \\) is the gravitational constant ( \\( 6.674 \\times 10^{-11} \\, \\text{N} \\cdot \\text{m}^2 / \\text{kg}^2 \\) ), - \\( M_e \\) is Earth's mass ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), - \\( r \\) is the distance from the center of the Earth. Kepler's Laws: These laws describe the motion of planets (and payloads in orbit) under the influence of gravity: Elliptical Orbits: Planets (or objects in space) move in elliptical orbits with the Sun (or Earth, in our case) at one focus. Equal Areas in Equal Times: A line connecting a planet to the Sun sweeps out equal areas in equal times. Harmonic Law: The square of the orbital period of a planet is proportional to the cube of the semi-major axis of its orbit.","title":"Gravitational Principles:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types","text":"Parabolic Trajectory: An object that has exactly the escape velocity will follow a parabolic trajectory. Elliptical Trajectory: An object in orbit will follow an elliptical path, which can be bound or unbound depending on the velocity and altitude. Hyperbolic Trajectory: If the object has more than the escape velocity, it will follow a hyperbolic trajectory and escape Earth\u2019s gravity.","title":"Trajectory Types:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity \\( v_e \\) is the minimum velocity needed for an object to escape Earth's gravitational influence, calculated as: \\[ v_e = \\sqrt{\\frac{2 G M_e}{r}} \\] Where: - \\( v_e \\) is the escape velocity, - \\( r \\) is the distance from the center of the Earth.","title":"Escape Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-numerical-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_e = 5.972e24 # Earth's mass (kg) R_e = 6371e3 # Earth's radius (m) # Initial conditions initial_position = np.array([7000e3, 0]) # Position (m) [x, y] initial_velocity = np.array([0, 10e3]) # Velocity (m/s) [vx, vy] # Time settings dt = 10 # Time step (seconds) T = 10000 # Total time for simulation (seconds) times = np.arange(0, T, dt) # Initialize arrays for position and velocity positions = [] velocities = [] position = initial_position velocity = initial_velocity # Function to compute the gravitational force def gravitational_force(position): r = np.linalg.norm(position) force_magnitude = G * M_e / r**2 force_direction = -position / r # Unit vector pointing towards Earth's center return force_magnitude * force_direction # Numerical integration (Euler's method) for t in times: positions.append(position) velocities.append(velocity) # Compute acceleration force = gravitational_force(position) acceleration = force / 1 # Assuming mass = 1 kg for simplicity # Update velocity and position using Euler's method velocity += acceleration * dt position += velocity * dt # Convert positions and velocities to arrays positions = np.array(positions) # Plot the trajectory plt.figure(figsize=(6, 6)) plt.plot(positions[:, 0], positions[:, 1], label='Trajectory') plt.scatter(0, 0, color='red', label='Earth') plt.title('Trajectory of a Freely Released Payload Near Earth') plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.legend() plt.grid(True) plt.axis('equal') plt.show() Graphical representations of orbital trajectories, escape velocities, and payload trajectories near Earth.","title":"Python Code: Numerical Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}